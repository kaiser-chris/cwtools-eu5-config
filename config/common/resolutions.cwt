types = {
    type[resolution] = {
        path = "game/common/resolutions"
        path = "game/in_game/common/resolutions"
        path = "game/main_menu/common/resolutions"
        path = "game/loading_screen/common/resolutions"
        file_extension = .txt
        localisation = {
            name = "$"
            desc = "$_desc"
        }
    }
}

resolution = {
    ## cardinality = 0..1
    international_organization_type = <international_organization>

    ## cardinality = 0..1
    loc = localisation

    ## cardinality = 0..inf
    select_trigger = single_alias_right[selected_trigger_clause]

    ### trigger, scope:actor is the country attempting to perform the action
    ## cardinality = 0..1
    potential = single_alias_right[trigger_clause]

    ### trigger, scope:actor is the country attempting to perform the action
    ## cardinality = 0..1
    allow = single_alias_right[trigger_clause]

    ### can actor vote. scope:actor is the country testing if it can vote or not; scope:recipient is the international organization
    ## cardinality = 0..1
    can_vote = single_alias_right[trigger_clause]

    ### is this resolution active. Used for elections mainly. If a resolution is live, then it will be tested to see if it can be finalized.
    ## cardinality = 0..1
    is_live = single_alias_right[trigger_clause]

    ### determines if the vote should be finalized right now. Before this trigger is run, any deadline is checked, deadlines take precedence over this trigger. Additional parameters are available here - scope:total_votes_needed is the total votes needed to win (if that is specified), scope:total_votes_available is the total number of votes that can be cast, and highest_vote is the total of whoever has the current highest vote. These can be used to implement voting thresholds.
    ## cardinality = 0..1
    should_finalize_vote = single_alias_right[trigger_clause]

    ### returns yes if this resolution must be voted on, no if it can be actioned unilaterally
    ## cardinality = 0..1
    requires_vote = single_alias_right[trigger_clause]

    ### does this require all votes to be explicitly set or do we just take the current opinion (basically, we use this for elections as they happen all of a sudden and we don't need to go through waiting for all countries to cast votes explicitly)
    ## cardinality = 0..1
    requires_explicit_votes = bool

    ## cardinality = 0..1
    show_message = bool

    ### listed in \common\prices\ and referenced by name (like price:<price_id>) or as a result of a script (like scope:target.price)
    ## cardinality = 0..1
    proposal_price = scope[price]

    ### multiplies the price; scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    price = value_field
    ### multiplies the price; scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    price = <script_value>
    ### multiplies the price; scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    price = <static_value>
    ### multiplies the price; scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    price = single_alias_right[formula]

    ### value script to get the number of votes each country has. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    votes = value_field
    ### value script to get the number of votes each country has. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    votes = <script_value>
    ### value script to get the number of votes each country has. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    votes = <static_value>
    ### value script to get the number of votes each country has. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    votes = single_alias_right[formula]

    ### value script to get the voting threshold for winning the vote. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    total_votes_needed = value_field
    ### value script to get the voting threshold for winning the vote. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    total_votes_needed = <script_value>
    ### value script to get the voting threshold for winning the vote. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    total_votes_needed = <static_value>
    ### value script to get the voting threshold for winning the vote. scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    total_votes_needed = single_alias_right[formula]

    ## cardinality = 0..inf
    alias_name[duration] = alias_match_left[duration]

    ### script to determine who is paying the price. By default, the actor
    ## cardinality = 0..1
    payer = scope[any]

    ### script to determine who gets paid. By default, nobody, the price disappears into the ether
    ## cardinality = 0..1
    payee = scope[any]

    ### use to ban the AI from using an action that is already handled in code OR to indicate how often to process
    ## cardinality = 0..1
    ai_tick = enum[character_interaction_ai_tick]

    ### how many ticks until next. script to determine how often this action should be checked for each country. root is the country. This is just a per-country check. So ai_tick = monthly and ai_tick_frequency = 6 means "check every 6 months"
    ## cardinality = 0..1
    ai_tick_frequency = int

    ### script for the AI to use for how much it wants to vote for whatever, scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    ai_will_do = single_alias_right[formula]

    ### script for the AI to use for how much it doesn't want a resolution to be rejected, scope:actor is the country we're calculating a score for; scope:proposer is the proposer country; scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    ai_proposer_risk = single_alias_right[formula]

    ### what happens when the resolution is passed, scope:proposer is the proposer country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc plus scope:price/scope:price_modifier/scope:payer/scope:payee returns the price details
    ## cardinality = 0..1
    effect = single_alias_right[effect_clause]

    ### modifiers applied to the member countries while a vote is ongoing
    ## cardinality = 0..1
    vote_ongoing_modifier = single_alias_right[modifier_clause]

    ### what happens when the resolution is proposed; scope:proposer is the proposer country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    propose_effect = single_alias_right[effect_clause]

    ### what happens when a resolution is rejected, scope:proposer is the proposer country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    ## cardinality = 0..1
    reject_effect = single_alias_right[effect_clause]

    ### what happens when a country votes in the resolution; scope:actor = the voter country, scope:proposer is the proposer country, scope:active_resolution is the resolution, scope:vote is the vote, scope:recipient, scope:target, scope:target_1, scope:target_2... etc
    ## cardinality = 0..1
    vote_effect = single_alias_right[effect_clause]

    ### what happens when a country removes its vote in the resolution; scope:actor = the voter country, scope:proposer is the proposer country, scope:active_resolution is the resolution, scope:recipient, scope:target, scope:target_1, scope:target_2... etc
    ## cardinality = 0..1
    abstain_effect = single_alias_right[effect_clause]

    ## cardinality = 0..1
    requires_explicit_votes = bool

    ### adds a cooldown for the action during which time it cannot be performed again
    ## cardinality = 0..1
    cooldown = {
        type = value_set[cooldown]

        alias_name[duration] = alias_match_left[duration]
    }
}
